const sqlite3 = require('sqlite3'); 
const loki = require('lokijs');
const winston = require('winston');

// To run: node db_converter.js
// This file automatically converts a LokiJS JSON database into a sqlite3 database.

/**
* A LokiJS => sqlite3 database converter.
* Automatically detects the table names and schemas in the database, creates
* the table in sqlite3, and imports all the data into the new database.
*/
class DatabaseConverter {
	constructor(oldDbFilename, newDbFilename) {
		this.oldFilename = oldDbFilename;
		this.newFilename = newDbFilename;
		this.oldDb = new loki(oldDbFilename);
		this.newDb = new sqlite3.Database(newDbFilename);
	}

	// Runs the conversion process.
	run() {
		let oldDb = this.oldDb;
		let newDb = this.newDb;
		let self = this;
		// Load the old database (with Loki).
		oldDb.loadDatabase({}, function (err) {
			if (err) {
				winston.info(err);
				return;
			} 

			// Collections are the tables.
			// Get all the names of the tables.
			const collections = oldDb.listCollections().map(v => v.name);
			newDb.run('BEGIN EXCLUSIVE TRANSACTION;');
			for (let name of collections) {
				let collection = oldDb.getCollection(name);
				let data = collection.find();
				if (!data) {
					continue;
				}

				// Assume the last item is representative and complete.
				const representativeItem = data[data.length - 1];
				// Holds all the new columns, expected entries are tuples of column name and data type.
				let newColumns = [];

				// (Attempt to) infer the database schema automatically.
				for (let [key, value] of Object.entries(representativeItem)) {
					// Find the data type.
					newColumns = self.getColumnDetails(key, value, newColumns);
				}

				winston.info(newColumns);

				// Create the table.
				newDb.serialize(() => {
					const flattenedColumns = newColumns.map(v => v.join(' '));
					const columnString = flattenedColumns.join(', ');
					newDb.run(`CREATE TABLE "${name}" (${columnString});`);
					winston.info(`CREATE TABLE "${name}" (${columnString});`);

					// Insert all the old data into the newly constructed table.
					// Comma-separated column names.
					const columnNamesString = newColumns.map(v => v[0]).join(', ');
					for (let item of data) {
						const flattenedItem = self.flattenObj(item);
						const dataString = self.quote(Object.values(flattenedItem)).join(', ');
						const insertionString = `INSERT INTO "${name}" (${columnNamesString}) VALUES (${dataString})`;
						winston.info(`INSERT INTO "${name}" (${columnNamesString}) VALUES (${dataString})`);
					}
				});
			}

			// Attempt to commit everything.
			// We can't use a try/catch because sqlite3 errors are not thrown by this command.
			// However, all previous changes will only be permanent if this succeeds. Therefore
			// no changes will be saved unless all changes are able to saved.
			newDb.run('COMMIT TRANSACTION;');
		});

	}

	// To protect against names with hyphens.
	// Double quotes around column names, single quotes around strings.
	protect(k) {
		return '"' + k + '"';
	}

	// Recursively determines the column type and adds the column schema to 
	// the existing array of column schema tuples, also unnests nested
	// objects and renames children columns to parent_child.
	getColumnDetails(key, value, existing) {
		// This strips out invalid column names like $loki (which is just the autogenerated index).
		// SQLite3 has rowid which is automatically generated so we don't need it.
		if (!key.match(/^[0-9a-zA-Z-_]+$/)) {
			return existing;
		}
		if (Number.isInteger(value)) {
			existing.push([this.protect(key), 'INTEGER']);
		}
		else if (typeof value === 'number') {
			existing.push([this.protect(key), 'NUMERIC']);
		}
		else if (typeof value === 'boolean' || value === null) {  // Technically not good - only doing this because onBreak is null which appears to be a boolean.
			existing.push([this.protect(key), 'BOOLEAN']);  // Internally, these are actually stored as numerics.
		}
		else if (typeof value === 'string') {
			existing.push([this.protect(key), 'TEXT']);
		}
		else if (value.constructor == Object) {
			// Unnest, it's a dictionary.
			for (let [subKey, subValue] of Object.entries(value)) {
				// Subcolumns are denoted with '_', e.g. maincolumn_subcolumn.
				existing = this.getColumnDetails(key + '_' + subKey, subValue, existing);
			}
		}
		else {
			existing.push([this.protect(key), 'BLOB']);
		}
		return existing;
	}
	
	// https://stackoverflow.com/questions/44134212/best-way-to-flatten-js-object-keys-and-values-to-a-single-depth-array
	flattenObj(obj, parent, res = {}){
		for(let key in obj){
		    let propName = parent ? parent + '_' + key : key;
		    if(typeof obj[key] == 'object'){
		        this.flattenObj(obj[key], propName, res);
		    } else {
		        res[propName] = obj[key];
		    }
		}
		return res;
	}

	// Wraps each item in the array in quotes if it is a string.
	quote(arr) {
		return arr.map((v) => {
			return typeof v === 'string' ? this.protect(v) : v;
		});
	}
}
 
let converter = new DatabaseConverter('./dmcdata.json', './dmcdata.db');
converter.run();