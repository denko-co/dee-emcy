const sqlite3 = require('sqlite3'); 
const loki = require('lokijs');
const winston = require('winston');

let newDb = new sqlite3.Database('./dmcdata.db');
let oldDb = new loki('./dmcdata.json');

// To run: node db_converter.js
// This file automatically converts a LokiJS JSON database into a sqlite3 database.
// It automatically detects the table names and schemas in the database, creates the
// tables in sqlite3, and imports all the data into the new database.

// Recursively determines the column type, also renames nested objects to parent_child.
function getColumnDetails(key, value, existing) {
	// This strips out invalid column names like $loki (which is just the autogenerated index).
	// SQLite3 has rowid which is automatically generated so we don't need it.
	if (!key.match(/^[0-9a-zA-Z-_]+$/)) {
		return existing;
	}
	// To protect against names with hyphens.
	// Double quotes around column names, single quotes around strings.
	function protect(k) {
		return '"' + k + '"';
	}
	if (Number.isInteger(value)) {
		existing.push([protect(key), 'INTEGER']);
	}
	else if (typeof value === 'number') {
		existing.push([protect(key), 'NUMERIC']);
	}
	else if (typeof value === 'boolean' || value === null) {  // Technically not good - only doing this because onBreak is null which appears to be a boolean.
		existing.push([protect(key), 'BOOLEAN']);  // Internally, these are actually stored as numerics.
	}
	else if (typeof value === 'string') {
		existing.push([protect(key), 'TEXT']);
	}
	else if (value.constructor == Object) {
		// Unnest, it's a dictionary.
		for (let [subKey, subValue] of Object.entries(value)) {
			// Subcolumns are denoted with '_', e.g. maincolumn_subcolumn.
			existing = getColumnDetails(key + '_' + subKey, subValue, existing);
		}
	}
	else {
		existing.push([protect(key), 'BLOB']);
	}
	return existing;
}

// https://stackoverflow.com/questions/44134212/best-way-to-flatten-js-object-keys-and-values-to-a-single-depth-array
function flattenObj(obj, parent, res = {}){
	for(let key in obj){
	    let propName = parent ? parent + '_' + key : key;
	    if(typeof obj[key] == 'object'){
	        flattenObj(obj[key], propName, res);
	    } else {
	        res[propName] = obj[key];
	    }
	}
	return res;
}

// Wraps each item in quotes or not depending on the type.
function quote(arr) {
	// Double quotes around column names, single quotes around strings.
	function protect(k) {
		return '\'' + k + '\'';
	}
	return arr.map((v) => {
		return typeof v === 'string' ? protect(v) : v;
	});
}

// Load the old database (with Loki).
oldDb.loadDatabase({}, function (err) {
	if (err) {
		winston.info(err);
		return;
	} 

	// Collections are the tables.
	// Get all the names of the tables.
	const collections = oldDb.listCollections().map(v => v.name);
	for (let name of collections) {
		let collection = oldDb.getCollection(name);
		let data = collection.find();
		if (!data) {
			continue;
		}

		// Assume the first item is representative and complete.
		const representativeItem = data[0];
		// Holds all the new columns, expected entries are tuples of column name and data type.
		let newColumns = [];

		// (Attempt to) infer the database schema automatically.
		for (let [key, value] of Object.entries(representativeItem)) {
			// Find the data type.
			newColumns = getColumnDetails(key, value, newColumns);
		}

		console.log(newColumns);

		// Create the table.
		newDb.serialize(() => {
			newDb.run('BEGIN EXCLUSIVE TRANSACTION;');
			const flattenedColumns = newColumns.map(v => v.join(' '));
			const columnString = flattenedColumns.join(', ');
			newDb.run(`CREATE TABLE "${name}" (${columnString});`);
			console.log(`CREATE TABLE "${name}" (${columnString});`);

			// Insert all the old data into the newly constructed table.
			// Comma-separated column names.
			const columnNamesString = newColumns.map(v => v[0]).join(', ');
			for (let item of data) {
				const flattenedItem = flattenObj(item);
				const dataString = quote(Object.values(flattenedItem)).join(', ');
				const insertionString = `INSERT INTO "${name}" (${columnNamesString}) VALUES (${dataString})`;
				console.log(`INSERT INTO "${name}" (${columnNamesString}) VALUES (${dataString})`);
			}

			newDb.run('COMMIT TRANSACTION;');
		});
	}
});